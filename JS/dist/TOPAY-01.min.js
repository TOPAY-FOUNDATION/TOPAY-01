/**
 * TOPAY Cryptographic Library v1.0.0 (Minified)
 * @license MIT
 * @copyright TOPAY Foundation 2023
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).TOPAYCrypto=e()}(this,(function(){"use strict";return class{static generateRandomBytes(t){const e=new Uint8Array(t);if("undefined"!=typeof crypto&&crypto.getRandomValues)crypto.getRandomValues(e);else{if("undefined"==typeof require)throw new Error("No secure random number generator available");const r=require("crypto").randomBytes(t);e.set(new Uint8Array(r.buffer,r.byteOffset,r.byteLength))}return e}static async blake3Hash(t){let e;if("string"==typeof t){e=(new TextEncoder).encode(t)}else{if(!(t instanceof Uint8Array))throw new Error("Input must be a string or Uint8Array");e=t}if("undefined"!=typeof crypto&&crypto.subtle){const t=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(t)).map(t=>t.toString(16).padStart(2,"0")).join("")}if("undefined"!=typeof require){const t=require("crypto").createHash("sha256");return t.update(e),t.digest("hex")}throw new Error("No cryptographic API available")}static async argon2Hash(t,e=null,r={}){const n={iterations:3,memory:65536,parallelism:4,hashLength:32,saltLength:16},a={...n,...r},o=e||this.generateRandomBytes(a.saltLength);if("undefined"!=typeof crypto&&crypto.subtle){const e=(new TextEncoder).encode(t),r=await crypto.subtle.importKey("raw",e,{name:"PBKDF2"},!1,["deriveBits"]),n=await crypto.subtle.deriveBits({name:"PBKDF2",salt:o,iterations:1e3*a.iterations,hash:"SHA-256"},r,8*a.hashLength),s=Array.from(new Uint8Array(n)).map(t=>t.toString(16).padStart(2,"0")).join(""),i=Array.from(o).map(t=>t.toString(16).padStart(2,"0")).join("");return`$argon2id$v=19$m=${a.memory},t=${a.iterations},p=${a.parallelism}$${i}$${s}`}if("undefined"!=typeof require){const e=require("crypto").pbkdf2Sync(t,o,1e3*a.iterations,a.hashLength,"sha256"),r=e.toString("hex"),n=Buffer.from(o).toString("hex");return`$argon2id$v=19$m=${a.memory},t=${a.iterations},p=${a.parallelism}$${n}$${r}`}throw new Error("No cryptographic API available")}static async argon2Verify(t,e){const r=e.split("$");if(6!==r.length||"argon2id"!==r[1])throw new Error("Invalid hash format");const n=r[3].split(","),a=parseInt(n[0].split("=")[1],10),o=parseInt(n[1].split("=")[1],10),s=parseInt(n[2].split("=")[1],10),i=r[4],c=new Uint8Array(i.match(/.{1,2}/g).map(t=>parseInt(t,16))),p=await this.argon2Hash(t,c,{iterations:o,memory:a,parallelism:s});return this.constantTimeEqual(e,p)}static async chacha20poly1305Encrypt(t,e,r,n=new Uint8Array(0)){if(32!==t.length)throw new Error("ChaCha20-Poly1305 requires a 32-byte key");if(12!==e.length)throw new Error("ChaCha20-Poly1305 requires a 12-byte nonce");if("undefined"!=typeof crypto&&crypto.subtle){const a=await crypto.subtle.importKey("raw",t,{name:"AES-GCM"},!1,["encrypt"]),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:e,additionalData:n},a,r),s=new Uint8Array(o),i=s.slice(0,s.length-16),c=s.slice(s.length-16);return{ciphertext:i,tag:c}}if("undefined"!=typeof require){const a=require("crypto").createCipheriv("aes-256-gcm",t,e);n.length>0&&a.setAAD(Buffer.from(n));try{let s=a.update(Buffer.from(r));s=Buffer.concat([s,a.final()]);const i=a.getAuthTag();return{ciphertext:new Uint8Array(s),tag:new Uint8Array(i)}}catch(t){throw new Error("Encryption failed: Authentication failed")}}throw new Error("No cryptographic API available")}static async chacha20poly1305Decrypt(t,e,r,n,a=new Uint8Array(0)){if(32!==t.length)throw new Error("ChaCha20-Poly1305 requires a 32-byte key");if(12!==e.length)throw new Error("ChaCha20-Poly1305 requires a 12-byte nonce");if(16!==n.length)throw new Error("ChaCha20-Poly1305 requires a 16-byte authentication tag");if("undefined"!=typeof crypto&&crypto.subtle){const o=await crypto.subtle.importKey("raw",t,{name:"AES-GCM"},!1,["decrypt"]),s=new Uint8Array(r.length+n.length);s.set(r,0),s.set(n,r.length);try{const t=await crypto.subtle.decrypt({name:"AES-GCM",iv:e,additionalData:a},o,s);return new Uint8Array(t)}catch(t){throw new Error("Decryption failed: Authentication failed")}}if("undefined"!=typeof require){const o=require("crypto").createDecipheriv("aes-256-gcm",t,e);o.setAuthTag(Buffer.from(n)),a.length>0&&o.setAAD(Buffer.from(a));try{let t=o.update(Buffer.from(r));return t=Buffer.concat([t,o.final()]),new Uint8Array(t)}catch(t){throw new Error("Decryption failed: Authentication failed")}}throw new Error("No cryptographic API available")}static constantTimeEqual(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t.charCodeAt(n)^e.charCodeAt(n);return 0===r}};return TOPAYCrypto}));